### **1️⃣ Code & Architecture**
- How does your solution follow SOLID principles?

	My code is designed in clean architecture approach which adheres to SOLID principles, making sure the api endpoint only reasonable for reading the request and sending back the data, The application layer orchestrate the use case. Dependency injection has been used to allow us to test and also easily refactor the code.

- How did you structure your API (Controllers, Services, Repositories)?

	I structured my project following clean architecture (onion)
```
/AITravel
 ├── /Presentation (Startup project, contains `Program.cs`, controllers)
   ├── /AUTravekAPI
 ├── /Application (Contains interfaces, CQRS handlers, business logic)
 ├── /Infrastructure (Contains `DbContext`, database-related logic, external api integration)
 ├── /Domaint (Contains entity models)
```

### **2️⃣ AI Integration**
- Which AI model did you use, and why?

	I used OpenAI o4-mini as it is sufficient to complete the task while keeping the cost minimal. 
- How does your API process user input to generate an itinerary?

	My API reads the user input and transform it into user prompt using my template. Also I added a system prompt to ensure the returned result from OpenAI follow my structure json schema.

### **3️⃣ Error Handling & Validation**
- How does your API handle incorrect or missing user input?

	I am using fluentValidation to validate user inputs you can find it under Application project.
- What are the key edge cases you considered?

	Adding a big date range might cause the API to timeout. This needs a future improvement to ensure no large date range is allowed or a way we can handle such large data. It timeout because OpenAI takes long then hit a limit or return a very long json reponse.

### **4️⃣ Performance & Scalability**
- How does your API handle multiple concurrent requests?

	I have made the whole app follow async approach which should provide a better performance while handling multiple request. There is also cancelation token to cancel the task if the user closes their browser or leave the website.
- What would you change to improve scalability?

	The application is built to scale. Containerization means it can run in cloud environments or Kubernetes clusters. Since we do not maintain server-side session or state (each request is independent), we can run multiple instances of the API in parallel to handle high traffic. The main bottleneck might be OpenAI API rate limits or costs – for that, we could consider request queuing or rate limiting on our side to avoid hitting the API too fast. If needed, one could also scale vertically by using more powerful instances, but horizontal scaling (multiple containers) is more effective given the stateless design. Also, using a persistent database for itineraries would allow sharing data between instances if needed (e.g., to avoid regenerating an itinerary if it was recently generated by another instance).

### **5️⃣ Additional Innovation (Bonus Points)**
- Did you implement any additional features or optimizations?
- How does your solution stand out from a standard AI itinerary generator?

	It is more structure and controlled input and output
